## Лабораторная работа №2

# Общая концепция

- Мультисписок (Multilist) — структура данных, где элементы объединены в несколько взаимосвязанных списков сразу (обычно используются разные критерии группировки). Чаще всего реализуются через узлы с множеством указателей.
- Очередь (Queue) — организация данных по принципу FIFO ("первым пришел — первым ушел"). Обычно строится на основе массива или связанного списка.
- Дек (Deque) — Double-ended queue, поддерживающая эффективные операции добавления и удаления элементов с обоих концов.
- Приоритетная очередь (Priority Queue) — особая форма очереди, где следующий извлекаемый элемент определяется не порядком прихода, а значением своего приоритета. За кулисами часто применяется структура "куча" (Heap).

# С++ (Императивный, производительность, STL)

Ключевая особенность: активное применение библиотек стандартной библиотеки (STL), поддержка шаблонов, прямое управление памятью, высокая скорость исполнения.

1.  Мультисписок
    - Реализация: Стандартная библиотека не предоставляет готовую структуру Multilist. Нужно самостоятельно создавать её на основе двухсвязных списков (std::list) или деревьев (например, применяя множественный компаратор для std::set, хотя формально это не список).
    - Пример: `struct Node { int data; Node* next_list1; Node* prev_list1; Node* next_list2; Node* prev_list2; };`
    - Особенности: Управление памятью и узлами выполняется вручную, что даёт полный контроль, но усложняет разработку и повышает вероятность ошибок.

2.  Очередь
    - Реализация: шаблон адаптера контейнера std::queue. По умолчанию использует структуру std::deque, но можно задать любую другую (например, std::list).
    - Пример: `std::queue<int> q;`
    - Особенности: сам по себе контейнером не является, обеспечивает лишь интерфейс над другим контейнером. Производительность сильно зависит от выбора базовой структуры.
3.  Дек
    - Реализация: класс std::deque — комбинированная структура данных, внутри использующая массивы блоков и карту указателей на них. Это позволяет быстро добавлять и удалять элементы с обоих концов, обеспечивая также быстрый доступ по индексу.
    - Пример: `std::deque<int> dq;`
    - Особенности: гибридная структура, совмещающая плюсы векторных и списочных подходов. Идеальна для эффективной реализации очередей и стэков.

4.  Приоритетная очередь
    - Реализация: адаптивный контейнер std::priority_queue. Внутри использует алгоритм работы с кучей (std::make_heap, std::push_heap, std::pop_heap), по умолчанию построенную на основе std::vector.
    - Пример: `std::priority_queue<int> pq;`
    - Особенности: автоматически сохраняет максимальное значение сверху (max-heap). Чтобы организовать min-heap, потребуется передать собственный компаратор. Прямой перебор всех элементов невозможен.

# Java (Объектно-ориентированный, сборщик мусора, богатая стандартная библиотека)

Ключевые черты: вся логика основана на объектах, наличие автоматического сбора мусора (GC), мощная стандартная библиотека коллекций (Collection Framework), отказ от явных указателей.

1.  Мультисписок
    - Реализация: отсутствует встроенная поддержка Multilist. Необходимо создать собственную структуру на основе узлов (Node), как в C++, однако без необходимости самостоятельного управления памятью.
    - Пример:
        ```java
        class MultiListNode<T> {
            T data;
            MultiListNode<T> nextA, prevA, nextB, prevB;
        }
        ```
    - Особенности:  Сборщик мусора освобождает разработчика от забот о контроле памяти, делая решение более безопасным, но ценой снижения эффективности из-за возможных издержек механизма сборки мусора и утраты полного контроля над управлением ресурсами.

2.  Очередь
    - Реализация: Интерфейс Queue с основными реализациями: LinkedList (двусвязный список) и ArrayDeque (реализован как изменяемый массив).
    - Пример: `Queue<Integer> queue = new LinkedList<>();`
    - Особенности: Класс ArrayDeque обычно превосходит LinkedList по показателям потребления памяти и производительности. Интерфейс Queue предлагает два варианта методов: первая группа (add(e) и remove()) бросает исключения при ошибках, вторая (offer(e) и poll()) возвращает специальные значения в случае неудачи.

3.  Дек
    - Реализация: Интерфейс Deque, используемый совместно с теми же реализациями: LinkedList и ArrayDeque.
    - Пример: `Deque<Integer> deque = new ArrayDeque<>();`
    - Особенности: Рекомендуемая реализация — ArrayDeque, подходящий вариант практически для любых задач. Интерфейс отличается богатым набором методов, обеспечивающих эффективное взаимодействие с обоими концами структуры.

4.  Приоритетная очередь
    - Реализация: Класс PriorityQueue, внутренний механизм которого основан на структуре минимальной кучи (min-heap), хранящей элементы в динамическом массиве.
    - Пример: `PriorityQueue<Integer> pq = new PriorityQueue<>();`
    - Особенности: По умолчанию устроена как минимальная куча, но порядок сортировки можно поменять с помощью собственного компаратора (Comparator). Подобно реализации в C++, приоритетная очередь не поддерживает гарантированную последовательность при полном переборе элементов, но позволяет извлекать их последовательно согласно установленному приоритету.

# Python (Динамическая типизация, лаконичность, "батарейки в комплекте")

Ключевые черты: Динамическое определение типов, компактный синтаксис, широкие возможности стандартных модулей («батарейки включены»), глобальная блокировка интерпретатора (GIL).

1.  Мультисписок
    - Реализация: Стандартной реализации нет. Можно представить с помощью словарей, списков или отдельных классов, как в Java/C++.
    - Пример: `multilist = {'list1': [], 'list2': []}` или класс, как в Java.
    - Особенности: Благодаря динамической типизации Python упрощает написание сложных структур, но теряет производительность и детализированный контроль над памятью по сравнению с низкоуровневыми языками вроде C++.

2.  Очередь
    - Реализация: Модуль queue предоставляет готовые потокобезопасные реализации очередей, включая обычную очередь (Queue) и очередь LIFO (LifoQueue). Если потоки не требуются, можно использовать модуль collections.deque.
    - Пример (многопоточная): `from queue import Queue; q = Queue()`
    - Особенности: Обычная очередь из модуля queue подходит для межпоточного взаимодействия. Если важна максимальная производительность в однопоточном сценарии, лучше выбрать deque из модуля collections.

3.  Дек
    - Реализация: Библиотека collections.deque реализует двунаправленную очередь (deque), работающую как кольцевой буфер, выполненный на основе двусвязного списка блоков.
    - Пример: `from collections import deque; dq = deque()`
    - Особенности: Этот инструмент хорошо справляется с добавлением и удалением элементов с обоих концов. Методы appendleft, popleft позволяют эффективно управлять структурой даже в условиях конкуренции потоков.

4.  Приоритетная очередь
    - Реализация: Модуль heapq превращает обычный список в двоичную кучу (min-heap), предоставляя функции для эффективного манипулирования ею. Альтернативно, существует потокобезопасная версия — queue.PriorityQueue, построенная на основе heapq.
    - Пример:
        ```python
        import heapq
        heap = []
        heapq.heappush(heap, 5)
        min_val = heapq.heappop(heap)
        ```
    - Особенности: Базируется на функционале работы с обычными списками. По умолчанию формируется мин-куча (min-heap). Для использования приоритетов в пользовательских объектах принято передавать кортеж вида (priority, item).

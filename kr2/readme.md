Задание 13. Генетический алгоритм: задача коммивояжёра
- Условие. Найти приближённое решение TSP с помощью генетического алгоритма.
- Алгоритм: ГА с упорядоченным кроссовером (OX) и мутацией перестановки.
- Язык примера: C++

```
vector<int> gaTsp(const vector<vector<int>>& dist, int popSize, int generations) {
 vector<vector<int>> population = initPopulation(popSize, dist.size());
 for (int gen = 0; gen < generations; gen++) {
 vector<double> fitness = calcFitness(population, dist);
 // ДОПИСАТЬ: отбор родителей, кроссовер, мутация
 // обновить population
 // Вернуть лучший маршрут
}
```
- Что дописать: функции отбора (например, турнирным методом), OX‑кроссовера и
мутации перестановки.

### Пошаговое описание алгоритма
### Шаг 1. Инициализация популяции
```
cpp
vector<vector<int>> initPopulation(int popSize, int nCities)
Создаётся popSize случайных перестановок городов 0..nCities‑1.
```
Каждая перестановка — возможный маршрут.
### Шаг 2. Основной цикл по поколениям
Для каждого поколения от 0 до generations ‑ 1:
## а) Вычисление фитнес‑функции
```
cpp
vector<double> calcFitness(const vector<vector<int>>& population, const vector<vector<int>>& dist)
Для каждого маршрута суммируется длина пути:
totalDist = dist[route[0]][route[1]] + dist[route[1]][route[2]] + ... + dist[route[n-1]][route[0]].
```
Фитнес = 1.0 / totalDist (чем короче путь, тем выше фитнес).

Пример:
Маршрут [0, 2, 1, 3] → длина = 100 → фитнес = 0.01.

## б) Создание нового поколения
Для каждой из popSize новых особей:
- Отбор родителей (турнирный, k = 3)
```
cpp
vector<int> selectParent(const vector<vector<int>>& population, const vector<double>& fitness)
```
- Случайным образом выбираются 3 особи из текущей популяции.
- Выбирается особь с максимальным фитнесом.
- Повторяется для второго родителя.
# Кроссовер (Ordered Crossover, OX)
```
cpp
vector<int> orderedCrossover(const vector<int>& parent1, const vector<int>& parent2)
```
- Выбирается случайный сегмент генов (например, позиции 1…2).
- Сегмент из parent1 копируется в потомка.
- Остальные города добавляются из parent2 в порядке их появления, пропуская уже добавленные.
# Мутация
```
cpp
void mutate(vector<int>& individual, double mutationRate = 0.1)
С вероятностью mutationRate (10 %) меняются местами два случайных города.
```
## в) Обновление популяции
Новая популяция заменяет старую.

### Шаг 3. Выбор лучшего решения
- После всех поколений вычисляется фитнес для всех особей финальной популяции.
- Выбирается маршрут с максимальным фитнесом (кратчайшим путём).
- Возвращается этот маршрут.

### Временная сложность:
O(G*P*n^2)
​
### Контрольный вопрос
## Табу‑лист в алгоритме табу‑поиска: концепция и роль
# Табу‑лист (tabu list) — это ключевой механизм кратковременной памяти алгоритма, который хранит информацию о недавно посещённых решениях или выполненных действиях, временно запрещая их повторное использование.

# Как работает табу‑лист
На каждой итерации алгоритм:
- Генерирует набор возможных «ходов» (вариаций текущего решения).
- Отсеивает ходы, попавшие в табу‑лист (они считаются запрещёнными).
- Выбирает лучший из разрешённых ходов.
- Выполняет ход, обновляет текущее решение.
- Добавляет совершённый ход в табу‑лист.
- При необходимости удаляет из списка самые старые записи (если достигнут лимит размера).

# Ключевые функции табу‑листа
- Предотвращение циклов
- Запрещает возврат к недавно посещённым решениям, исключая зацикливание алгоритма.
- Пример: если алгоритм только что перешёл от решения A к решению B, табу‑лист временно запретит обратный переход B → A.
- Выход из локальных оптимумов
- Вынуждает алгоритм исследовать новые области пространства решений, даже если они временно хуже текущего.
- Эффект: алгоритм «выталкивается» из тупиковых зон, где жадные методы застревают.
- Управление разнообразием поиска
- Балансирует между:
-- интенсификацией (углублённый поиск в перспективной зоне);
-- диверсификацией (исследование новых областей).
# Табу‑лист стимулирует диверсификацию, блокируя уже опробованные пути.

# Экономия ресурсов
Вместо хранения полных решений часто сохраняются их атрибуты (например, индексы изменённых элементов), что снижает нагрузку на память.

# Вариант 16. Жадный алгоритм для упаковки контейнеров (Bin Packing)

## Задача: реализовать несколько жадных стратегий для упаковки предметов в контейнеры. 

## Требования: 
- Стратегия "First Fit" (FF)
- Стратегия "First Fit Decreasing" (FFD)
- Стратегия "Best Fit"
- Сравнить результаты всех трех стратегий
  
## Входные данные:
- Размеры предметов: [7, 5, 3, 8, 2, 6, 4, 9]
- Размер контейнера: 10

# Объяснение работы алгоритма:
1. First Fit (FF)
Принцип работы:
- Обрабатываем предметы в исходном порядке.
- Для каждого предмета ищем первый контейнер, в который он помещается.
- Если ни один контейнер не подходит — открываем новый.

2. First Fit Decreasing (FFD)
Принцип работы:
- Сначала сортируем все предметы по убыванию размеров.
- Затем применяем алгоритм First Fit.


3. Best Fit (BF)
Принцип работы:
- Для каждого предмета ищем контейнер, где после его размещения останется минимальный свободный объём (но достаточный).
- Если нет подходящего контейнера — открываем новый.

# Сравнение алгоритмов
1. First Fit (FF)
Плюсы:
- Простота реализации.
- Быстрая работа на практике.
Минусы:
- Результат сильно зависит от порядка предметов.
- Может давать неоптимальные решения.

2. First Fit Decreasing (FFD)
Плюсы:
- Обычно даёт лучшее решение, чем FF.
- Простая модификация FF.
Минусы:
- Требуется предварительная сортировка.

3. Best Fit (BF)
Плюсы:
- Часто эффективнее FF (но не всегда FFD).
- Логично с точки зрения оптимизации.
Минусы:
- Требует полного просмотра всех контейнеров для каждого предмета.

4.Сравнение результатов
First Fit (FF) - Базовый жадный алгоритм
First Fit Decreasing (FFD) - Сортировка не помогла сократить число контейнеров в этом случае
Best Fit (BF) - Выбор «наиболее плотного» контейнера не дал выигрыша
Вывод: На данных [7,5,3,8,2,6,4,9] и вместимости 10 все три стратегии дали одинаковый результат — 5 контейнеров.
Это не означает, что стратегии эквивалентны: на других данных FFD обычно лучше FF, а BF может быть лучше или хуже FF.

# Временная сложность
1. First Fit (FF)
Внешний цикл: O(n) — по числу предметов.
Внутренний цикл: в худшем случае O(n) контейнеров.
Суммирование содержимого контейнера: O(n) в худшем случае.
Итого: O(n ⋅ n ⋅ n) = O(n³).
Оптимизация: Если хранить сумму для каждого контейнера (не пересчитывать sum(bin)), сложность снижается до O(n²).

2.First Fit Decreasing (FFD)
Сортировка: O(n log n).
First Fit: O(n²) (с оптимизацией хранения сумм).Итого: O(n log n + n²) = O(n²).

3.Best Fit (BF)
Внешний цикл: O(n) — по числу предметов.Поиск лучшего контейнера: O(n) контейнеров × O(1) при хранении сумм.
Итого: O(n²).

# Контрольный вопрос 16

# Пояснение добавленного кода
1. getNeighbors(const vector<int>& board)
2. Находит позицию пустой клетки (0).
Проверяет 4 направления (вверх/вниз/влево/вправо).
Для каждого допустимого направления:
- создаёт копию текущего поля;
- меняет местами 0 и соседнюю плитку;
- добавляет новое состояние в список соседей.

2. Блок генерации соседей в aStarPuzzle
Вызывает getNeighbors() для текущего состояния.
Для каждого соседа:
- Проверяет, не было ли это состояние уже обработано (closed).
- Вычисляет новую стоимость пути: g = curr.moves + 1.
- Вычисляет эвристику h для нового состояния.
- Добавляет новый узел в приоритетную очередь open.

3. Структура State и компаратор
board — текущее расположение плиток.
moves (g) — количество ходов от старта.
heuristic (h) — оценка оставшегося пути.
Оператор < обеспечивает работу priority_queue: приоритет по f = g + h (чем меньше, тем выше приоритет).

# Временная сложность
- Теоретическая сложность: O(NlogN), где N — число достижимых состояний.
- Практическая сложность: O(KlogK), где K — число посещённых состояний (зависит от эвристики и начального состояния).


